<#
//=======================================================================
// The code below operates on DryIoc.Container. 
// The result will be resolution delegates generated by DryIoc.Container,
// then these delegates will be used by DryIocZero.Container at run-time.
//
// TODO: Change the code below to:
// 1. Configure DryIoc.Сontainer with your rules and conventions.
// 2. Register your services and implementations. 
// Please ensure to include assemblies and namespaces where they reside.
// 3. Identify the resolution roots: the services to be Resovled, rather then injected.
// 4. When done Save the DryIocZero/Container.Generated.tt class. Confirm on VisualStudio prompt if any.
// 5. Check result Container.Generated.cs for general compilation errors 
// and for resolution errors listed under comment "FAILED to generate resolution for"
//
//=======================================================================
#>
<#@ assembly Name="$(SolutionDir)packages\DryIoc.dll.2.10.0\lib\net45\DryIoc.dll" #>
<#@ import Namespace="DryIoc" #>

<#// TODO: Insert assemblies and namespaces with your services to register in container #>
<#@ assembly Name="$(SolutionDir)IocPerformance\bin\Release\IocPerformance.exe" #>
<#@ import Namespace="IocPerformance.Classes.Complex" #>
<#@ import Namespace="IocPerformance.Classes.Conditions" #>
<#@ import Namespace="IocPerformance.Classes.Dummy" #>
<#@ import Namespace="IocPerformance.Classes.Multiple" #>
<#@ import Namespace="IocPerformance.Classes.Properties" #>
<#@ import Namespace="IocPerformance.Classes.Standard" #>

<#+
// TODO: Specify your container and registrations
IContainer GetContainerWithRegistrations()
{
    var c = new Container();

    RegisterDummies(c);
    RegisterStandard(c);
    RegisterComplex(c);
    RegisterPropertyInjection(c);
    RegisterConditional(c);
    RegisterMultiple(c);

    return c;
}

private void RegisterDummies(Container c)
{
    c.Register<IDummyOne, DummyOne>();
    c.Register<IDummyTwo, DummyTwo>();
    c.Register<IDummyThree, DummyThree>();
    c.Register<IDummyFour, DummyFour>();
    c.Register<IDummyFive, DummyFive>();
    c.Register<IDummySix, DummySix>();
    c.Register<IDummySeven, DummySeven>();
    c.Register<IDummyEight, DummyEight>();
    c.Register<IDummyNine, DummyNine>();
    c.Register<IDummyTen, DummyTen>();
}

private void RegisterStandard(Container c)
{
    c.Register<ISingleton1, Singleton1>(Reuse.Singleton);
    c.Register<ISingleton2, Singleton2>(Reuse.Singleton);
    c.Register<ISingleton3, Singleton3>(Reuse.Singleton);
    c.Register<ITransient1, Transient1>();
    c.Register<ITransient2, Transient2>();
    c.Register<ITransient3, Transient3>();
    c.Register<ICombined1, Combined1>();
    c.Register<ICombined2, Combined2>();
    c.Register<ICombined3, Combined3>();
    c.Register<ICalculator1, Calculator1>();
    c.Register<ICalculator2, Calculator2>();
    c.Register<ICalculator3, Calculator3>();
}

private void RegisterComplex(Container c)
{
    c.Register<ISubObjectOne, SubObjectOne>();
    c.Register<ISubObjectTwo, SubObjectTwo>();
    c.Register<ISubObjectThree, SubObjectThree>();
    c.Register<IFirstService, FirstService>(Reuse.Singleton);
    c.Register<ISecondService, SecondService>(Reuse.Singleton);
    c.Register<IThirdService, ThirdService>(Reuse.Singleton);
    c.Register<IComplex1, Complex1>();
    c.Register<IComplex2, Complex2>();
    c.Register<IComplex3, Complex3>();
}

private void RegisterPropertyInjection(Container c)
{
    c.Register<IServiceA, ServiceA>(Reuse.Singleton);
    c.Register<IServiceB, ServiceB>(Reuse.Singleton);
    c.Register<IServiceC, ServiceC>(Reuse.Singleton);

    c.Register<ISubObjectA, SubObjectA>(made: PropertiesAndFields.Auto);
    c.Register<ISubObjectB, SubObjectB>(made: PropertiesAndFields.Auto);
    c.Register<ISubObjectC, SubObjectC>(made: PropertiesAndFields.Auto);

    c.Register<IComplexPropertyObject1, ComplexPropertyObject1>(made: PropertiesAndFields.Auto);
    c.Register<IComplexPropertyObject2, ComplexPropertyObject2>(made: PropertiesAndFields.Auto);
    c.Register<IComplexPropertyObject3, ComplexPropertyObject3>(made: PropertiesAndFields.Auto);
}

private void RegisterConditional(Container c)
{
    c.Register<ImportConditionObject1>();
    c.Register<ImportConditionObject2>();
    c.Register<ImportConditionObject3>();

    c.Register<IExportConditionInterface, ExportConditionalObject>(
        setup: Setup.With(condition: r => r.Parent.ImplementationType == typeof(ImportConditionObject1)));

    c.Register<IExportConditionInterface, ExportConditionalObject2>(
        setup: Setup.With(condition: r => r.Parent.ImplementationType == typeof(ImportConditionObject2)));

    c.Register<IExportConditionInterface, ExportConditionalObject3>(
        setup: Setup.With(condition: r => r.Parent.ImplementationType == typeof(ImportConditionObject3)));
}

private void RegisterMultiple(Container c)
{
    c.Register<ImportMultiple1>();
    c.Register<ImportMultiple2>();
    c.Register<ImportMultiple3>();
    c.Register<ISimpleAdapter, SimpleAdapterOne>();
    c.Register<ISimpleAdapter, SimpleAdapterTwo>();
    c.Register<ISimpleAdapter, SimpleAdapterThree>();
    c.Register<ISimpleAdapter, SimpleAdapterFour>();
    c.Register<ISimpleAdapter, SimpleAdapterFive>();
}

// TODO: Identify resolution roots services. Return true for the service you'll expect to Resolve from container.
public static readonly Type[] Roots =
{
    typeof(IComplex1),
    typeof(IComplex2),
    typeof(IComplex3),
    typeof(IDummyOne),
    typeof(ImportMultiple1),
    typeof(ImportMultiple2),
    typeof(ImportMultiple3),
    typeof(IComplexPropertyObject1),
    typeof(IComplexPropertyObject2),
    typeof(IComplexPropertyObject3),
    typeof(ICombined1),
    typeof(ICombined2),
    typeof(ICombined3),
    typeof(ISingleton1),
    typeof(ISingleton2),
    typeof(ISingleton3),
    typeof(ITransient1),
    typeof(ITransient2),
    typeof(ITransient3),
    typeof(ImportConditionObject1),
    typeof(ImportConditionObject2),
    typeof(ImportConditionObject3)
};

// Specify what resolution roots should be generated
bool IsResolutionRoot(ServiceRegistrationInfo info)
{
    // EXAMPLE: I am selecting the roots registered with Setup.With(asResolutionRoot: true) or AsResolutionRootAttribute.
    // You may apply any custom filter against input ServiceRegistrationInfo.
    //return ContainerTools.SetupAsResolutionRoots(info);
    return Array.IndexOf(Roots, info.ServiceType) != -1;
}
#>